# AI Studio Proxy - 提交机制详解

本文档详细说明提交提示时的试错顺序、成功判断机制，以及为什么有时候点击按钮失败但组合键能成功。

## 目录

- [提交试错顺序](#提交试错顺序)
- [提交成功的判断机制](#提交成功的判断机制)
- [为什么点击失败但组合键成功](#为什么点击失败但组合键成功)
- [完整流程图](#完整流程图)

## 提交试错顺序

### 概述

系统采用三层降级策略，确保提示能够成功提交到 AI Studio 页面。

**代码位置**：`browser_utils/page_controller.py:904-924`

```python
# 优先回车提交，其次按钮提交，最后组合键提交
submitted_successfully = await self._try_enter_submit(prompt_textarea_locator, check_client_disconnected)
if not submitted_successfully:
    self.logger.info(f"[{self.req_id}] 回车提交失败，尝试点击提交按钮...")
    button_clicked = False
    try:
        # 提交前再处理一次潜在对话框，避免按钮点击被拦截
        await self._handle_post_upload_dialog()
        await submit_button_locator.click(timeout=5000)
        self.logger.info(f"[{self.req_id}] ✅ 提交按钮点击完成。")
        button_clicked = True
    except Exception as click_err:
        self.logger.error(f"[{self.req_id}] ❌ 提交按钮点击失败: {click_err}")
        await save_error_snapshot(f"submit_button_click_fail_{self.req_id}")

    if not button_clicked:
        self.logger.info(f"[{self.req_id}] 按钮提交失败，尝试组合键提交...")
        combo_ok = await self._try_combo_submit(prompt_textarea_locator, check_client_disconnected)
        if not combo_ok:
            self.logger.error(f"[{self.req_id}] ❌ 组合键提交也失败。")
            raise Exception("Submit failed: Enter, Button, and Combo key all failed")
```

### 第一优先：回车键提交

**函数**：`_try_enter_submit()`
**代码位置**：`browser_utils/page_controller.py:1032-1132`

**工作流程**：

1. **检测操作系统**（用于后续组合键选择）
```python
# page_controller.py:1036-1057
host_os_from_launcher = os.environ.get('HOST_OS_FOR_SHORTCUT')
is_mac_determined = False

if host_os_from_launcher == "Darwin":
    is_mac_determined = True
elif host_os_from_launcher in ["Windows", "Linux"]:
    is_mac_determined = False
else:
    # 使用浏览器检测
    try:
        user_agent_data_platform = await self.page.evaluate("() => navigator.userAgentData?.platform || ''")
    except Exception:
        user_agent_string = await self.page.evaluate("() => navigator.userAgent || ''")
        user_agent_string_lower = user_agent_string.lower()
        if "macintosh" in user_agent_string_lower or "mac os x" in user_agent_string_lower:
            user_agent_data_platform = "macOS"
        else:
            user_agent_data_platform = "Other"

    is_mac_determined = "mac" in user_agent_data_platform.lower()
```

2. **聚焦输入框并记录原始内容**
```python
# page_controller.py:1061-1071
await prompt_textarea_locator.focus(timeout=5000)
await self._check_disconnect(check_client_disconnected, "After Input Focus")
await asyncio.sleep(0.1)

# 记录提交前的输入框内容，用于验证
original_content = ""
try:
    original_content = await prompt_textarea_locator.input_value(timeout=2000) or ""
except Exception:
    # 如果无法获取原始内容，仍然尝试提交
    pass
```

3. **按下回车键**
```python
# page_controller.py:1074-1084
self.logger.info(f"[{self.req_id}] 尝试回车键提交")
try:
    await self.page.keyboard.press('Enter')
except Exception:
    try:
        await prompt_textarea_locator.press('Enter')
    except Exception:
        pass

await self._check_disconnect(check_client_disconnected, "After Enter Press")
await asyncio.sleep(2.0)  # 等待2秒让提交生效
```

4. **验证提交是否成功**（见下节"提交成功的判断机制"）

**优点**：
- 最快速、最直接
- 不受 UI 遮挡影响
- 键盘事件可以穿透多层 DOM

**缺点**：
- AI Studio 可能改变键盘快捷键行为
- 某些特殊输入法状态下可能失效

### 第二优先：点击提交按钮

**代码位置**：`browser_utils/page_controller.py:907-917`

**工作流程**：

1. **处理可能的遮挡对话框**
```python
# page_controller.py:910-911
# 提交前再处理一次潜在对话框，避免按钮点击被拦截
await self._handle_post_upload_dialog()
```

对话框处理逻辑（`_handle_post_upload_dialog`，line 712-732）：
```python
async def _handle_post_upload_dialog(self):
    """处理上传后可能出现的授权/版权确认对话框，优先点击同意类按钮，不主动关闭重要对话框。"""
    try:
        overlay_container = self.page.locator('div.cdk-overlay-container')
        if await overlay_container.count() == 0:
            return

        # 候选同意按钮的文本/属性
        agree_texts = [
            'Agree', 'I agree', 'Allow', 'Continue', 'OK',
            '确定', '同意', '继续', '允许'
        ]
        # 统一在 overlay 容器内查找可见按钮
        for text in agree_texts:
            try:
                btn = overlay_container.locator(f"button:has-text('{text}')")
                if await btn.count() > 0 and await btn.first.is_visible(timeout=300):
                    await btn.first.click()
                    self.logger.info(f"[{self.req_id}] 上传后对话框: 点击按钮 '{text}'。")
                    await asyncio.sleep(0.3)
                    break
            except Exception:
                pass
    except Exception:
        pass
```

2. **点击提交按钮**
```python
# page_controller.py:912-914
await submit_button_locator.click(timeout=5000)
self.logger.info(f"[{self.req_id}] ✅ 提交按钮点击完成。")
button_clicked = True
```

**按钮选择器**（`config/selectors.py:13`）：
```python
SUBMIT_BUTTON_SELECTOR = 'button[aria-label="Run"].run-button, ms-run-button button[type="submit"].run-button'
```

**优点**：
- 最符合用户实际操作
- 不依赖键盘快捷键配置

**缺点**：
- 可能被 UI 层遮挡（弹窗、对话框等）
- Playwright 的点击有严格的可见性和可点击性检查
- 需要等待按钮启用状态

### 第三优先：组合键提交

**函数**：`_try_combo_submit()`
**代码位置**：`browser_utils/page_controller.py:1134-1224`

**工作流程**：

1. **检测操作系统，确定组合键**
```python
# page_controller.py:1138-1157
host_os_from_launcher = os.environ.get('HOST_OS_FOR_SHORTCUT')
is_mac_determined = False
if host_os_from_launcher == "Darwin":
    is_mac_determined = True
elif host_os_from_launcher in ["Windows", "Linux"]:
    is_mac_determined = False
else:
    try:
        user_agent_data_platform = await self.page.evaluate("() => navigator.userAgentData?.platform || ''")
    except Exception:
        user_agent_string = await self.page.evaluate("() => navigator.userAgent || ''")
        user_agent_string_lower = user_agent_string.lower()
        if "macintosh" in user_agent_string_lower or "mac os x" in user_agent_string_lower:
            user_agent_data_platform = "macOS"
        else:
            user_agent_data_platform = "Other"
    is_mac_determined = "mac" in user_agent_data_platform.lower()

shortcut_modifier = "Meta" if is_mac_determined else "Control"  # Mac: Cmd, Windows/Linux: Ctrl
shortcut_key = "Enter"
```

2. **聚焦并按下组合键**
```python
# page_controller.py:1159-1184
await prompt_textarea_locator.focus(timeout=5000)
await self._check_disconnect(check_client_disconnected, "After Input Focus")
await asyncio.sleep(0.1)

# 记录提交前的输入框内容，用于验证
original_content = ""
try:
    original_content = await prompt_textarea_locator.input_value(timeout=2000) or ""
except Exception:
    pass

self.logger.info(f"[{self.req_id}] 尝试组合键提交: {shortcut_modifier}+{shortcut_key}")
try:
    await self.page.keyboard.press(f'{shortcut_modifier}+{shortcut_key}')
except Exception:
    # 降级：分步按键
    try:
        await self.page.keyboard.down(shortcut_modifier)
        await asyncio.sleep(0.05)
        await self.page.keyboard.press(shortcut_key)
        await asyncio.sleep(0.05)
        await self.page.keyboard.up(shortcut_modifier)
    except Exception:
        pass

await self._check_disconnect(check_client_disconnected, "After Combo Press")
await asyncio.sleep(2.0)  # 等待2秒让提交生效
```

3. **验证提交是否成功**（见下节）

**组合键对应**：
- **macOS**：`Command + Enter` (Meta + Enter)
- **Windows/Linux**：`Control + Enter`

**优点**：
- 最终兜底方案
- 键盘事件不受 UI 遮挡影响
- 有分步按键的降级策略

**缺点**：
- 依赖 AI Studio 支持该组合键
- 某些浏览器或环境可能拦截组合键

## 提交成功的判断机制

### 三种验证方法

无论使用哪种提交方式，系统都会通过**三种方法**验证提交是否成功，**任意一种方法通过即认为提交成功**。

**代码位置**：
- 回车键验证：`browser_utils/page_controller.py:1086-1122`
- 组合键验证：`browser_utils/page_controller.py:1186-1214`

### 验证方法 1：检查输入框是否清空

**原理**：提交成功后，AI Studio 会自动清空输入框。

**代码实现**：
```python
# page_controller.py:1089-1093 (回车键验证)
# page_controller.py:1188-1191 (组合键验证)
submission_success = False
try:
    # 方法1: 检查原始输入框是否清空
    current_content = await prompt_textarea_locator.input_value(timeout=2000) or ""
    if original_content and not current_content.strip():
        self.logger.info(f"[{self.req_id}] 验证方法1: 输入框已清空，提交成功")
        submission_success = True
```

**判断逻辑**：
1. 提交前记录原始内容 `original_content`
2. 提交后等待 2 秒
3. 读取当前内容 `current_content`
4. 如果原始内容不为空 且 当前内容为空 → 提交成功

**优点**：
- 最直观的判断方式
- 验证速度快

**局限性**：
- 如果原始内容就是空的，无法验证
- 某些情况下清空可能有延迟

### 验证方法 2：检查提交按钮是否禁用

**原理**：提交后，AI Studio 会禁用提交按钮（防止重复提交），直到响应完成。

**代码实现**：
```python
# page_controller.py:1095-1104 (回车键验证)
# page_controller.py:1192-1200 (组合键验证)
if not submission_success:
    submit_button_locator = self.page.locator(SUBMIT_BUTTON_SELECTOR)
    try:
        is_disabled = await submit_button_locator.is_disabled(timeout=2000)
        if is_disabled:
            self.logger.info(f"[{self.req_id}] 验证方法2: 提交按钮已禁用，提交成功")
            submission_success = True
    except Exception:
        pass
```

**判断逻辑**：
1. 定位提交按钮（选择器：`button[aria-label="Run"].run-button`）
2. 检查按钮的 `disabled` 属性
3. 如果按钮被禁用 → 提交成功

**优点**：
- 不依赖输入框内容
- 可以验证任何情况下的提交

**局限性**：
- 如果 AI Studio 改变按钮行为，可能失效
- 某些网络延迟情况下，按钮状态更新可能有延迟

### 验证方法 3：检查响应容器是否出现

**原理**：提交成功后，AI Studio 会立即创建新的响应容器来显示 AI 的回复。

**代码实现**：
```python
# page_controller.py:1106-1118 (回车键验证)
# page_controller.py:1201-1211 (组合键验证)
if not submission_success:
    try:
        response_container = self.page.locator(RESPONSE_CONTAINER_SELECTOR)
        container_count = await response_container.count()
        if container_count > 0:
            # 检查最后一个容器是否是新的
            last_container = response_container.last
            if await last_container.is_visible(timeout=1000):
                self.logger.info(f"[{self.req_id}] 验证方法3: 检测到响应容器，提交成功")
                submission_success = True
    except Exception:
        pass
```

**响应容器选择器**（`config/selectors.py:19`）：
```python
RESPONSE_CONTAINER_SELECTOR = 'ms-chat-turn .chat-turn-container.model'
```

**判断逻辑**：
1. 查找所有响应容器
2. 如果容器数量 > 0
3. 检查最后一个容器是否可见
4. 如果可见 → 提交成功

**优点**：
- 最可靠的验证方式
- 直接检查提交的最终效果

**局限性**：
- 响应容器出现可能有延迟
- 如果 AI Studio 改变 DOM 结构，选择器可能失效

### 容错机制

**代码位置**：`browser_utils/page_controller.py:1119-1122` (回车), `1212-1214` (组合键)

```python
except Exception as verify_err:
    self.logger.warning(f"[{self.req_id}] 提交验证过程出错: {verify_err}")
    # 出错时假定提交成功，让后续流程继续
    submission_success = True
```

**说明**：
- 如果三种验证方法都出现异常，**默认假定提交成功**
- 这是为了避免因为验证失败导致流程卡死
- 后续的响应等待逻辑会进一步确认是否真的提交成功

## 为什么点击失败但组合键成功

### 问题描述

用户有时会遇到这样的情况：
- 点击提交按钮失败（Playwright 报错：元素不可点击）
- 但使用 `Control/Command + Enter` 组合键却能成功提交

### 根本原因分析

#### 1. UI 层遮挡问题

**最常见的原因**：上传文件后出现的对话框遮挡了提交按钮。

**代码证据**（`browser_utils/page_controller.py:910-911`）：
```python
# 提交前再处理一次潜在对话框，避免按钮点击被拦截
await self._handle_post_upload_dialog()
```

**对话框类型**（`page_controller.py:720-723`）：
```python
# 候选同意按钮的文本/属性
agree_texts = [
    'Agree', 'I agree', 'Allow', 'Continue', 'OK',
    '确定', '同意', '继续', '允许'
]
```

**场景**：
1. 用户上传图片/文件
2. AI Studio 弹出版权确认对话框
3. 对话框的透明遮罩（`cdk-overlay-backdrop`）覆盖整个页面
4. 提交按钮被遮罩挡住，无法点击
5. 但键盘事件可以穿透遮罩，直接触发提交

#### 2. Playwright 的严格点击检查

**Playwright 点击要求**：
- 元素必须可见（visible）
- 元素必须在视口内（in viewport）
- 元素必须可点击（not covered by other elements）
- 元素必须启用（not disabled）

**代码位置**（`browser_utils/page_controller.py:912`）：
```python
await submit_button_locator.click(timeout=5000)
```

**选择器**（`config/selectors.py:13`）：
```python
SUBMIT_BUTTON_SELECTOR = 'button[aria-label="Run"].run-button, ms-run-button button[type="submit"].run-button'
```

**失败场景**：
1. 按钮被其他元素遮挡（z-index 更高的层）
2. 按钮在视口外（页面滚动导致）
3. 按钮正在动画中（过渡效果）
4. 按钮的可点击区域被压缩

**键盘事件的优势**：
- 键盘事件不检查元素的可见性
- 键盘事件直接发送到聚焦的元素（输入框）
- 键盘事件可以穿透多层 DOM 结构

#### 3. 提交按钮启用状态的时序问题

**等待按钮启用**（`browser_utils/page_controller.py:891-899`）：
```python
# 等待发送按钮启用
wait_timeout_ms_submit_enabled = 100000
try:
    await self._check_disconnect(check_client_disconnected, "填充提示后等待发送按钮启用 - 前置检查")
    await expect_async(submit_button_locator).to_be_enabled(timeout=wait_timeout_ms_submit_enabled)
    self.logger.info(f"[{self.req_id}] ✅ 发送按钮已启用。")
except Exception as e_pw_enabled:
    self.logger.error(f"[{self.req_id}] ❌ 等待发送按钮启用超时或错误: {e_pw_enabled}")
    await save_error_snapshot(f"submit_button_enable_timeout_{self.req_id}")
    raise
```

**场景**：
1. 代码检测到按钮已启用
2. 等待 0.3 秒（line 902）
3. 尝试点击按钮
4. **但在这 0.3 秒内，按钮状态可能又变了**（比如上传进度导致）
5. 点击失败
6. 组合键不检查按钮状态，直接提交

#### 4. 浏览器事件处理机制差异

**点击事件的传播**：
```
用户点击 → Playwright 模拟 → 浏览器接收 → 事件捕获 → 事件冒泡 → 目标元素处理
```

**键盘事件的传播**：
```
用户按键 → Playwright 模拟 → 浏览器接收 → 聚焦元素处理（无需冒泡）
```

**关键差异**：
- 点击事件需要经过完整的事件冒泡流程，任何父元素都可以阻止
- 键盘事件直接发送到聚焦的元素，中间层级难以拦截
- AI Studio 可能在某些层级上阻止了点击事件，但没有阻止键盘事件

### 解决方案设计

#### 为什么采用三层降级

**代码设计思路**（`page_controller.py:904-924`）：

1. **第一优先：回车键**
   - 最简单、最快
   - 用户习惯（很多聊天应用都是回车提交）
   - 不受 UI 遮挡影响

2. **第二优先：点击按钮**
   - 在回车键失效时启用
   - 处理对话框遮挡（`_handle_post_upload_dialog`）
   - 最符合实际用户操作

3. **第三优先：组合键**
   - 最终兜底方案
   - Mac: `Command + Enter`
   - Windows/Linux: `Control + Enter`
   - 有分步按键的降级策略

#### 对话框处理机制

**代码位置**：`browser_utils/page_controller.py:712-732`

```python
async def _handle_post_upload_dialog(self):
    """处理上传后可能出现的授权/版权确认对话框，优先点击同意类按钮，不主动关闭重要对话框。"""
    try:
        overlay_container = self.page.locator('div.cdk-overlay-container')
        if await overlay_container.count() == 0:
            return

        # 候选同意按钮的文本/属性
        agree_texts = [
            'Agree', 'I agree', 'Allow', 'Continue', 'OK',
            '确定', '同意', '继续', '允许'
        ]
        # 统一在 overlay 容器内查找可见按钮
        for text in agree_texts:
            try:
                btn = overlay_container.locator(f"button:has-text('{text}')")
                if await btn.count() > 0 and await btn.first.is_visible(timeout=300):
                    await btn.first.click()
                    self.logger.info(f"[{self.req_id}] 上传后对话框: 点击按钮 '{text}'。")
                    await asyncio.sleep(0.3)
                    break
            except Exception:
                pass
    except Exception:
        pass
```

**工作流程**：
1. 查找 overlay 容器（Material Design 的遮罩层）
2. 在容器内查找"同意"类按钮
3. 支持中英文按钮文本
4. 点击第一个找到的同意按钮
5. 等待 0.3 秒让对话框关闭

**调用时机**：
- 上传文件后（`page_controller.py:849`）
- 点击提交按钮前（`page_controller.py:911`）

### 实际案例分析

#### 案例 1：上传图片后的版权确认

**场景**：
```
1. 用户上传图片
2. AI Studio 弹出版权确认对话框："I agree to use this content responsibly"
3. 对话框遮罩覆盖整个页面
4. 代码尝试点击提交按钮 → 失败（元素被遮挡）
5. 对话框处理机制点击"Agree"按钮
6. 但对话框关闭有延迟
7. 第二次点击按钮失败
8. 组合键直接提交 → 成功
```

**日志输出**：
```
[abc1234] 回车提交失败，尝试点击提交按钮...
[abc1234] 上传后对话框: 点击按钮 'I agree'。
[abc1234] ❌ 提交按钮点击失败: element is not visible
[abc1234] 按钮提交失败，尝试组合键提交...
[abc1234] 尝试组合键提交: Control+Enter
[abc1234] 验证方法1: 输入框已清空，组合键提交成功
[abc1234] ✅ 组合键提交成功
```

#### 案例 2：按钮状态时序问题

**场景**：
```
1. 代码填充提示文本
2. 等待按钮启用（检测到已启用）
3. 等待 0.3 秒
4. 上传文件完成，按钮短暂禁用
5. 尝试点击按钮 → 失败（按钮已禁用）
6. 组合键不检查按钮状态 → 成功
```

#### 案例 3：页面滚动导致按钮不在视口

**场景**：
```
1. 输入很长的提示文本
2. 输入框自动扩展，推高页面
3. 提交按钮滚动到视口外
4. Playwright 点击失败（元素不在视口）
5. 组合键聚焦在输入框 → 成功
```

### 技术对比总结

| 方面 | 点击按钮 | 键盘事件（回车/组合键） |
|------|----------|------------------------|
| **可见性检查** | 严格检查 | 不检查 |
| **遮挡检查** | 检查 z-index | 可穿透 |
| **视口检查** | 必须在视口内 | 不需要 |
| **禁用状态** | 检查 disabled | 不检查（组合键） |
| **事件传播** | 需要完整冒泡 | 直接到聚焦元素 |
| **对话框影响** | 会被遮挡 | 可穿透 |
| **浏览器兼容性** | 高 | 可能被拦截 |

## 完整流程图

```
开始提交
  │
  ├─ 第一步：等待提交按钮启用
  │   └─ 超时（100秒）→ 抛出异常
  │
  ├─ 第二步：尝试回车键提交
  │   ├─ 聚焦输入框
  │   ├─ 记录原始内容
  │   ├─ 按下 Enter
  │   ├─ 等待 2 秒
  │   └─ 验证成功？
  │       ├─ 是 → 提交成功 ✓
  │       └─ 否 → 继续下一步
  │
  ├─ 第三步：尝试点击提交按钮
  │   ├─ 处理遮挡对话框
  │   │   ├─ 查找 overlay 容器
  │   │   └─ 点击同意按钮
  │   ├─ 点击提交按钮
  │   └─ 成功？
  │       ├─ 是 → 提交成功 ✓
  │       └─ 否 → 继续下一步
  │
  ├─ 第四步：尝试组合键提交
  │   ├─ 检测操作系统
  │   │   ├─ macOS → Command + Enter
  │   │   └─ Windows/Linux → Control + Enter
  │   ├─ 聚焦输入框
  │   ├─ 记录原始内容
  │   ├─ 按下组合键
  │   │   ├─ 尝试单键 (Meta+Enter)
  │   │   └─ 失败 → 分步按键
  │   ├─ 等待 2 秒
  │   └─ 验证成功？
  │       ├─ 是 → 提交成功 ✓
  │       └─ 否 → 全部失败
  │
  └─ 第五步：全部失败
      └─ 抛出异常: "Submit failed: Enter, Button, and Combo key all failed"


验证提交成功（三种方法，任意一种通过即成功）
  │
  ├─ 方法1：输入框是否清空
  │   ├─ 读取当前内容
  │   └─ 原始内容不空 且 当前内容为空 → 成功 ✓
  │
  ├─ 方法2：提交按钮是否禁用
  │   ├─ 定位提交按钮
  │   └─ 按钮被禁用 → 成功 ✓
  │
  └─ 方法3：响应容器是否出现
      ├─ 查找响应容器
      ├─ 获取最后一个容器
      └─ 容器可见 → 成功 ✓
```

## 调试技巧

### 1. 查看提交日志

启用调试日志：
```bash
# .env 文件
DEBUG_LOGS_ENABLED=true
```

查看提交相关日志：
```bash
# 查找提交相关日志
docker logs ai-studio-proxy-container 2>&1 | grep -E "提交|submit|回车|按钮|组合键"

# 查看特定请求的提交日志
docker logs ai-studio-proxy-container 2>&1 | grep "abc1234"  # 替换为实际的 req_id
```

### 2. 快照文件分析

当提交失败时，系统会保存快照：

**快照位置**：
- 宿主机：`项目根目录/errors_py/`
- 容器内：`/app/errors_py/`

**快照文件名格式**：
```
submit_button_click_fail_{req_id}_{timestamp}.png
submit_button_click_fail_{req_id}_{timestamp}.html
```

**分析步骤**：
1. 打开 PNG 截图，查看页面状态
2. 查找是否有对话框遮挡
3. 查看提交按钮的状态（启用/禁用）
4. 打开 HTML 文件，检查 DOM 结构

### 3. 常见问题排查

#### 问题：回车键总是失败

**可能原因**：
1. AI Studio 改变了键盘快捷键配置
2. 输入框未正确聚焦
3. 浏览器拦截了键盘事件

**排查方法**：
```bash
# 查看日志中的操作系统检测
docker logs ai-studio-proxy-container 2>&1 | grep "HOST_OS_FOR_SHORTCUT"

# 查看聚焦是否成功
docker logs ai-studio-proxy-container 2>&1 | grep "After Input Focus"
```

#### 问题：所有提交方式都失败

**可能原因**：
1. 提交按钮选择器失效（AI Studio 更新了 UI）
2. 输入框选择器失效
3. 网络连接问题导致页面卡住

**排查方法**：
1. 查看最新的错误快照
2. 检查选择器是否还能定位到元素
3. 手动在浏览器中测试提交

#### 问题：点击按钮总是失败但组合键成功

**确认是对话框遮挡**：
```bash
# 查看对话框处理日志
docker logs ai-studio-proxy-container 2>&1 | grep "上传后对话框"

# 查看快照中是否有 overlay
# 打开 HTML 快照，搜索 "cdk-overlay" 或 "mat-dialog"
```

**解决方案**：
- 已经在代码中实现了对话框处理
- 如果还是失败，可能需要添加更多的同意按钮文本到 `agree_texts` 列表

## 相关文件

- 核心实现：`browser_utils/page_controller.py`
  - `submit_prompt()` (line 855-932)
  - `_try_enter_submit()` (line 1032-1132)
  - `_try_combo_submit()` (line 1134-1224)
  - `_handle_post_upload_dialog()` (line 712-732)
- 选择器定义：`config/selectors.py`
  - `SUBMIT_BUTTON_SELECTOR` (line 13)
  - `PROMPT_TEXTAREA_SELECTOR` (line 7)
  - `RESPONSE_CONTAINER_SELECTOR` (line 19)
- 错误快照：`browser_utils/operations.py`
  - `save_error_snapshot()` (line 433-482)

## 总结

1. **提交试错顺序**：回车键 → 点击按钮 → 组合键，三层降级确保成功
2. **成功判断**：输入框清空 或 按钮禁用 或 响应容器出现，三种方法任意通过即可
3. **点击失败但组合键成功的原因**：
   - UI 层遮挡（对话框）
   - Playwright 严格检查
   - 按钮状态时序问题
   - 键盘事件可穿透遮罩

这种多层降级设计确保了在各种复杂情况下都能成功提交，大大提高了系统的鲁棒性。
